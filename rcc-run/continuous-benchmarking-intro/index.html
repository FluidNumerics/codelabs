
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Get Started with Continuous Benchmarking using RCC-Run</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="TO DO"
                  id="rcc-run/continuous-benchmarking-intro"
                  title="Get Started with Continuous Benchmarking using RCC-Run"
                  environment="web"
                  feedback-link="https://octoskelo.atlassian.net/servicedesk/customer/portal/1/create/140">
    
      <google-codelab-step label="Introduction" duration="0">
        <p><strong>Last Updated:</strong> 2022-03-20</p>
<h2 is-upgraded><strong>What you will build</strong></h2>
<h2 is-upgraded><strong>What you will learn</strong></h2>
<ul>
<li>How to use Google Cloud Build to drive automated building and testing of a research application</li>
<li>How to use the RCC-Run builder to add benchmarking to a Cloud Build build pipeline</li>
<li>How to create a dashboard with Data Studio to visualize application performance data generated by RCC-Run</li>
</ul>
<h2 is-upgraded><strong>What you will need</strong></h2>
<ul>
<li>A Google Cloud Identity, Workspace, or Gmail account</li>
<li>An active Google Cloud project</li>
</ul>
<aside class="special"><p><strong>Note :</strong> If you are attending a training activity with Fluid Numerics, you have been issued a waterchange.org training account and an active Google Cloud project.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Set up your Google Cloud Project" duration="15">
        <p>When you start a new project on Google Cloud, by default, no services are available for use. To configure a new project for CI/CD and Continuous Benchmarking, you need to enable a number of Google Cloud APIs and align the appropriate roles with the Cloud Build Service account. To simplify this process, we have provided <a href="https://www.terraform.io/" target="_blank">Terraform infrastructure-as-code</a> to configure a Google Cloud project so that it is ready to use for Continuous Benchmarking.</p>
<ol type="1" start="1">
<li>Open a Google Cloud Shell by navigating to <a href="https://shell.cloud.google.com/?show=terminal" target="_blank">https://shell.cloud.google.com/?show=terminal</a> </li>
<li>Configure the gcloud SDK to set your Google Cloud project ID</li>
</ol>
<pre>export PROJECT=$(gcloud projects list --limit=1 --format=&#34;value(projectId)&#34;)
gcloud config set project $PROJECT</pre>
<ol type="1" start="3">
<li>Next, clone the rcc-run-demo repository and navigate to the ci/tf subdirectory included in this repo. </li>
</ol>
<pre>git clone https://github.com/fluidnumerics/rcc-run-demo ~/rcc-run-demo
cd ~/rcc-run-demo/ci/tf</pre>
<p><br>This directory contains Terraform infrastructure as code that will configure your Google Cloud project by (1) enabling the Compute Engine, Cloud Build, Container Registry, Big Query, and Identity &amp; Access Management API,  (2) aligning the necessary IAM permissions for your Cloud Build Service account, and (3) creating a Big Query dataset to store benchmark data.<br></p>
<ol type="1" start="4">
<li>The Terraform infrastructure as code consists of a few files written in HCL syntax. The <code>main.tf</code> file provides a template for resource creation and <code>io.tf</code> specifies the variables you have control over for concretizing the deployment. The provided <code>fluid.auto.tfvars</code> defines the concrete values for your deployment. In this example, the only value you need to provide is the project ID for your Google Cloud project. Before creating a terraform plan, you will need to set this variable in fluid.auto.tfvars</li>
</ol>
<pre>sed -i &#34;s/&lt;project&gt;/${PROJECT}/g&#34; fluid.auto.tfvars</pre>
<ol type="1" start="5">
<li>Create a Terraform plan and review the changes that will be made to your project.</li>
</ol>
<pre>terraform init
terraform validate
terraform plan -out=tfplan</pre>
<ol type="1" start="6">
<li>Apply the plan.</li>
</ol>
<pre>terraform apply &#34;tfplan&#34;</pre>
<p>Once the plan is applied, you will have created the following resources :</p>
<ul>
<li>All of the necessary APIs will be enabled (Big Query, Cloud Build, Container Registry, Compute, IAM)</li>
<li>A VPC network for deploying compute resources</li>
<li>All of the necessary IAM permissions for your Cloud Build service account</li>
<li>BigQuery Data Set</li>
</ul>
<p>You can view your BigQuery data set by visiting <a href="https://console.cloud.google.com/bigquery" target="_blank">https://console.cloud.google.com/bigquery</a> and navigating to your project&#39;s &#34;rcc_run&#34; table.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Manually Test the Application Build" duration="5">
        <p>In this section, you will learn how to manually trigger a build of a Docker image using Cloud Build. The rcc-run-demo repository comes with a basic Cloud Build pipeline that runs a single step to build a simple Fortran application.</p>
<p>Google Cloud Build executes steps in a build pipeline using &#34;Builders&#34;. A &#34;Builder&#34; is a Docker container that provides an environment executing a specific step in your application&#39;s build process. In the example repository, the build pipeline is defined in ci/cloudbuild.yaml.</p>
<pre>steps:

- id: Build Docker Image
  name: &#39;gcr.io/cloud-builders/docker&#39;
  args: [&#39;build&#39;,
         &#39;.&#39;,
         &#39;-f&#39;,&#39;docker/Dockerfile&#39;,
         &#39;-t&#39;,
         &#39;gcr.io/${PROJECT_ID}/smoother:latest&#39;
  ]

- id: Test
  name: &#39;gcr.io/cloud-builders/docker&#39;
  args: [&#39;run&#39;,
         &#39;gcr.io/${PROJECT_ID}/smoother:latest&#39;,
         &#39;smoother&#39;,&#39;1000&#39;,&#39;1000&#39;,&#39;100&#39;
  ]

images: [&#39;gcr.io/${PROJECT_ID}/smoother:latest&#39;]
</pre>
<aside class="special"><p><strong>Note</strong>: The ${PROJECT_ID} is a <a href="https://cloud.google.com/build/docs/configuring-builds/substitute-variable-values#using_default_substitutions" target="_blank">default substitution variable</a> that is automatically set to your active project in Google Cloud.</p>
</aside>
<p>This build executes two steps. In the first step, the Docker image is created using the Dockerfile recipe under <code>docker/Dockerfile</code>. In the second step, the created Docker image is then used to run a test of the application ( <code>smoother</code> ) within the Cloud Build environment. If both steps are successful, the resulting Docker image will be published to Container Registry.</p>
<aside class="special"><p><strong>Note</strong>: For reference, this example application is a 2-D smoother that applies a 9 point Gaussian stencil operator to a grid of data. The first two arguments set the grid size ( number of x and y grid cells) and the third argument sets the number of iterations. With this, you can vary the size of the work</p>
</aside>
<p>If you&#39;re interested in how the Docker image is created, you can look at the Dockerfile recipe under <code>docker/Dockerfile</code>.</p>
<pre>FROM debian:latest

ENV DEBIAN_FRONTEND=noninteractive   \
    LANGUAGE=en_US.UTF-8 \
    LANG=en_US.UTF-8 \
    LC_ALL=en_US.UTF-8

RUN apt-get -yqq update \
 &amp;&amp; apt-get -yqq install --no-install-recommends \
        build-essential \
        g++ \
        gcc \
        gfortran \
        make \
        gcovr \
 &amp;&amp; rm -rf /var/lib/apt/lists/*

COPY . /build/

RUN cd /build/src &amp;&amp; \
    make

ENV PATH=$PATH:/opt/demo/bin</pre>
<p>This <code>Dockerfile</code> provides instructions to install compilers and make tools on top of the Debian operating system. After installing these prerequisites, the local directory for the repository is copied into the image and the source code is compiled using the provided <code>src/Makefile</code>. Last, the binary path for the application is added to the default <code>PATH</code> environment variable</p>
<p>To run a build manually, you can use the gcloud SDK to submit a build.</p>
<ol type="1" start="1">
<li>Navigate to the root directory of the rcc-run-demo repository</li>
</ol>
<pre>cd ~/rcc-run-demo</pre>
<ol type="1" start="2">
<li>Use the gcloud SDK to submit a build. Here, we will run the build such that the build output is directed to your Cloud Shell environment</li>
</ol>
<pre>gcloud builds submit . --config=ci/cloudbuild.yaml </pre>
<p>Once the build is complete, the Docker image is posted to <a href="https://console.cloud.google.com/gcr" target="_blank">Google Container Registry</a>.</p>
<p>Google Cloud Build also stores build logs, which can be viewed at any time from the <a href="https://console.cloud.google.com/cloud-build/builds" target="_blank">Google Cloud Build Dashboard</a>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Create the rcc-run Docker image" duration="10">
        <p>The rcc-run application is packaged as a Docker image so that it can be called as a builder in Cloud Build. Before we add the rcc-run builder to the Cloud Build pipeline, we need to create a Docker image that contains the rcc-run application. The Dockerfile recipe and the build pipeline to create the Docker container image are available on the <a href="https://github.com/fluidnumerics/rcc-run" target="_blank">https://github.com/fluidnumerics/rcc-run</a> repository.</p>
<ol type="1" start="1">
<li>Clone the rcc-run repository in your Cloud Shell</li>
</ol>
<pre>git clone https://github.com/fluidnumerics/rcc-run ~/rcc-run</pre>
<ol type="1" start="2">
<li>Manually submit a build to create the rcc-run builder</li>
</ol>
<pre>cd ~/rcc-run
gcloud builds submit . --config=ci/cloudbuild.release.yaml --substitutions=TAG_NAME=latest</pre>
<aside class="special"><p><strong>Note</strong>: This example of manually triggering a build shows how to add variable substitutions to the build process. When creating <a href="https://cloud.google.com/build/docs/automating-builds/create-manage-triggers" target="_blank">build triggers,</a> you also have the option to set the values for build variables, which can give you flexibility in templatizing your build and testing process.</p>
</aside>
<p>Once the build is complete, the rcc-run Docker image is posted to <a href="https://console.cloud.google.com/gcr" target="_blank">Google Container Registry</a>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Add a Build Step to create a Singularity Image" duration="15">
        <p>RCC-Run currently only accepts Google Compute Engine VM Images or Singularity images as artifacts that can be tested. Since, in this example, our build system creates a Docker image and Singularity can readily convert a Docker image, we will add a build step to create a Singularity image from the Docker image previously created.</p>
<p>Recall that a Cloud Build Builder is just a Docker container. Because of this, we can use any publicly available Docker image for a step in our build process. A Docker image containing Singularity is publicly available at <a href="https://quay.io/repository/singularity/singularity" target="_blank">https://quay.io/repository/singularity/singularity</a>. The resolvable path that can be referenced by Cloud Build is <code>quay.io/singularity/singularity</code>, and here we&#39;ll use version 3.7.1.</p>
<p>When we use this Docker image as a build step, we essentially gain access to the Singularity command line interface, which will allow us to build a Singularity image from a local Docker image. If we were running such a command locally, we would do the following : </p>
<pre>singularity build my-image.sif docker-daemon://docker-image/</pre>
<p>To add this as a step to the Cloud Build pipeline, we need to define the build step by specifying :</p>
<ul>
<li><code>id</code> - The the human-readable name to give to the build step</li>
<li><code>name</code> - The path to the Docker image to use for this build step</li>
<li><code>args</code> - The arguments to pass to the default entry point for the Docker image (in this case, the arguments for the <code>singularity</code> CLI)</li>
</ul>
<p>To add this build step,</p>
<ol type="1" start="1">
<li>Navigate to the rcc-run-demo repository in your Cloud Shell</li>
</ol>
<pre>cd ~/rcc-run-demo</pre>
<ol type="1" start="2">
<li>Open <code>ci/cloudbuild.yaml</code> in a text editor (e.g. vim or nano) and add the following after the &#34;Test&#34; step</li>
</ol>
<pre>- id: Convert to Singularity Image
  name: &#39;quay.io/singularity/singularity:v3.7.1&#39;
  args: [&#39;build&#39;,
         &#39;smoother.sif&#39;,
         &#39;docker-daemon://gcr.io/${PROJECT_ID}/smoother:latest&#39;
  ]</pre>
<ol type="1" start="3">
<li>Save the file and exit the text editor.</li>
<li>Manually submit a build to verify your changes.</li>
</ol>
<pre>gcloud builds submit . --config=ci/cloudbuild.yaml --async</pre>
<aside class="special"><p><strong>Note</strong>: The --async flag submits a build and returns control of the terminal immediately so that you can carry on other work. At any time, you can view build logs from the <a href="https://console.cloud.google.com/cloud-build/builds" target="_blank">Google Cloud Build Dashboard</a>.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Add a test script and RCC-Run test configuration file" duration="20">
        <p>We are now at a stage where we can configure tests with RCC-Run. When you use the RCC-Run build step, an auto-scaling cluster will be created on your behalf for running tests on larger compute resources than are offered through Cloud Build by default. Upon creating the cluster, the working directories within Cloud Build, which includes your repository&#39;s directories, will be mirrored onto the cluster. Additionally, the Singularity image created in the previous step will also be copied up to the cluster.</p>
<p>The RCC-Run cluster comes with (by default) Slurm (20.11), Singularity (3.7.1), OpenMPI 4.0.2, CUDA Toolkit (11.2), and ROCm (4.3.2). This allows you to run serial, parallel (MPI only), GPU accelerated, and multi-GPU accelerated applications within the RCC-Run build step. </p>
<h2 is-upgraded>Add a test script</h2>
<p>Tests of your application are executed by running Slurm batch jobs. Because of this, RCC-Run requires that tests are defined within a python or shell script. When creating the test script, you can take advantage of <a href="https://fluid-run.readthedocs.io/en/latest/Reference/environment_variables.html" target="_blank">built-in environment variables</a> defined by RCC-Run.</p>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>Variable</strong></p>
</td><td colspan="1" rowspan="1"><p><strong>Description</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>WORKSPACE</code></p>
</td><td colspan="1" rowspan="1"><p>The path to the working directory where your job is executed.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>PROJECT</code></p>
</td><td colspan="1" rowspan="1"><p>The Google Cloud project hosting your test cluster.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>GIT_SHA</code></p>
</td><td colspan="1" rowspan="1"><p>The git sha associated with the run test.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>SINGULARITY_IMAGE</code></p>
</td><td colspan="1" rowspan="1"><p>The full path to the Singularity image on the test cluster.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>ENV_FILE</code></p>
</td><td colspan="1" rowspan="1"><p>The full path to a file containing environment variable definitions</p>
</td></tr>
</table>
<p>For our purposes, we want to create a simple shell script that navigates to the working directory for the benchmark and simply runs our application underneath singularity.</p>
<ol type="1" start="1">
<li>Navigate to the rcc-run-demo repository in your Cloud Shell</li>
<li>Open a new file in a text editor (e.g. vim or nano) under the <code>ci/</code> directory called <code>singularity_exec.sh</code> and add the following :</li>
</ol>
<pre>#!/bin/bash

cd ${WORKSPACE}
singularity exec $SINGULARITY_IMAGE smoother 1000 1000 100</pre>
<ol type="1" start="3">
<li>Save your changes and exit the text editor</li>
</ol>
<p>In this example, we&#39;re simply repeating the test we&#39;ve already done in the Cloud Build pipeline. In practice, RCC-Run is typically used for executing benchmarks on larger (and perhaps GPU accelerated) resources.</p>
<h2 is-upgraded><strong>Add the RCC-Run Configuration File</strong></h2>
<p>Now that we have a test script for running our simple application test, we need to create a file that defines what tests are run and on what compute resources on Google Cloud. RCC-Run expects a file in YAML syntax to define a list of tests. </p>
<p>Each test is defined by :</p>
<ul>
<li><code>command_group</code> - A human readable name used to group benchmark runs in the RCC-Run database. By default, commands in the same command group are scheduled with job dependencies in the order they are specified.</li>
<li><code>execution_command</code> - This is the path to the python or shell script relative to the root directory of your repository with any command line arguments.</li>
<li><code>output_directory</code> - The relative path within the Cloud Build workspace where your applications output will be directed.</li>
<li><code>partition</code> - The Slurm partition to submit the benchmark to. By <a href="https://github.com/FluidNumerics/rcc-run/blob/main/etc/rcc-ephemeral/default/fluid.auto.tfvars#L22" target="_blank">default</a>, only a c2-standard-8 (8 vCPU Intel Cascadelake) partition is provided. Provided you have sufficient quota, you can override the default benchmarking cluster to expose more <a href="https://cloud.google.com/compute/docs/machine-types" target="_blank">machine families offered on Google Cloud</a>.</li>
<li><code>batch_options</code> - Command line options sent to Slurm&#39;s sbatch command. This allows you to specify the amount of resources that are needed to complete your benchmark.</li>
</ul>
<p>Here, we will create a RCC-Run configuration file that executes only a single test in the c2-standard-8 partition.</p>
<ol type="1" start="1">
<li>Navigate to the rcc-run-demo repository in your Cloud Shell</li>
<li>Open a new file in a text editor (e.g. vim or nano) under the <code>ci/</code> directory called <code>rcc-run.yaml</code> and add the following :</li>
</ol>
<pre>tests:
- command_group: &#34;smoother_1000_1000_100&#34;
  execution_command: &#34;ci/singularity_exec.sh&#34;
  output_directory: &#34;smoother_c2&#34;
  partition: &#34;c2-standard-8&#34;
  batch_options: &#34;-N1 --time=10:00 --exclusive&#34;</pre>
<ol type="1" start="3">
<li>Save your changes and exit the text editor</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Add the RCC-Run Build Step" duration="20">
        <p>At this stage, we now have the necessary ingredients to run a benchmark with RCC-Run within the build pipeline. The purpose of RCC-Run is to encourage you to version control your testing and benchmarking process while also rewarding you with a database of benchmark information (wall-time, vCPU-hour, and max memory usage) that is aligned with the version of your code (Git SHA), the specific build (Build ID), the compute hardware you run on (partition), how the application was deployed (artifact type), and (optionally) other build information (e.g. compiler, compiler flags, target architecture, etc.)</p>
<p>In this example, we&#39;ll add a call to the rcc-run Docker image you created previously to align the minimal amount of required information. The <a href="https://fluid-run.readthedocs.io/en/latest/Reference/cli.html#cli-arguments" target="_blank">command line interface for RCC-run</a> requires only a few arguments; for our purposes we will define the following : </p>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>Argument</strong></p>
</td><td colspan="1" rowspan="1"><p><strong>Value</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>--build-id</code></p>
</td><td colspan="1" rowspan="1"><p><code>${BUILD_ID}</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>--git-sha</code></p>
</td><td colspan="1" rowspan="1"><p><code>${GIT_SHA}</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>--ci-file</code></p>
</td><td colspan="1" rowspan="1"><p><code>ci/rcc-run.yaml</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>--artifact-type</code></p>
</td><td colspan="1" rowspan="1"><p><code>singularity</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>--singularity-image</code></p>
</td><td colspan="1" rowspan="1"><p><code>smoother.sif</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>--project</code></p>
</td><td colspan="1" rowspan="1"><p><code>${PROJECT_ID}</code></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>--save-results</code></p>
</td><td colspan="1" rowspan="1"></td></tr>
</table>
<p>Most of the arguments should be familiar at this point, but we&#39;ll discuss a new variable here</p>
<ul>
<li><code>--save-results</code> : When this flag is not passed, RCC-Run will report the benchmarking results only to STDOUT, which is only available in the Cloud Build logs. By passing this flag, RCC-Run will export the benchmark data to your BigQuery dataset. </li>
</ul>
<p>Here, we will add a build step for RCC-Run after the &#34;Convert to Singularity Image&#34; build step.</p>
<ol type="1" start="1">
<li>Navigate to the rcc-run-demo repository in your Cloud Shell</li>
<li>Open the ci/cloudbuild.yaml build pipeline file  in a text editor (e.g. vim or nano) and add the following after the &#34;Convert to Singularity Image&#34; build step :</li>
</ol>
<pre>- id: RCC-Run
  name: &#39;gcr.io/${PROJECT_ID}/rcc-run:latest&#39;
  args:
  - &#39;--build-id=${BUILD_ID}&#39;
  - &#39;--git-sha=${COMMIT_SHA}&#39;
  - &#39;--project=${PROJECT_ID}&#39;
  - &#39;--artifact-type=singularity&#39;
  - &#39;--singularity-image=smoother.sif&#39;
  - &#39;--ci-file=ci/rcc-run.yaml&#39;
  - &#39;--save-results&#39;</pre>
<ol type="1" start="3">
<li>The default time limit for builds is 10 minutes. This build may take a little over 10 minutes to complete.  We can override the default build timeout, by adding the following at the end of the <strong>ci/cloudbuild.yaml</strong> file,</li>
</ol>
<pre>timeout: 900s</pre>
<ol type="1" start="4">
<li>Save your changes and exit the text editor.</li>
<li>Manually submit a build to verify your changes.</li>
</ol>
<pre>gcloud builds submit . --config=ci/cloudbuild.yaml --async</pre>
<aside class="special"><p><strong>Note</strong>: The --async flag submits a build and returns control of the terminal immediately so that you can carry on other work. At any time, you can view build logs from the <a href="https://console.cloud.google.com/cloud-build/builds" target="_blank">Google Cloud Build Dashboard</a>.</p>
</aside>
<p>When using RCC-Run, the build time will increase due to the fact that we now have to provision compute resources. Additionally, the local Cloud Build  workspace is transferred to and from the cluster.</p>
<p>Once the build is complete, you will be able to preview the data in your <a href="https://console.cloud.google.com/bigquery" target="_blank">rcc-apps BigQuery dataset</a>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Customize the RCC Cluster Partitions" duration="20">
        <p>One of the goals of RCC-Run is to enable you to assess performance of your application across multiple platforms, including those with GPUs. The default cluster, however, only comes with a single compute partition. Because of this, rcc-run allows for you to provide your own configuration so that you can customize the compute resources available during benchmarking.</p>
<p>Under-the-hood, RCC-Run uses <a href="https://www.terraform.io/" target="_blank">Terraform infrastructure-as-code</a> with the <a href="https://github.com/fluidnumerics/rcc-tf" target="_blank">rcc-tf</a> module to deploy a Slurm based cluster on. There are <a href="https://github.com/FluidNumerics/rcc-run/blob/main/etc/rcc-ephemeral/io.tf" target="_blank">a large number of documented customization options</a>, but in this tutorial we&#39;ll only discuss how to modify compute partitions so that you can expose other compute instances.</p>
<h2 is-upgraded>Add RCC Tfvars</h2>
<p>First, you need to add a Terraform variables file for rcc-tf to the rcc-run-demo repository. The easiest way to do this is to start from the default tfvars file provided by rcc-run. </p>
<pre>cp ~/rcc-run/etc/rcc-ephemeral/default/fluid.auto.tfvars ~/rcc-run-demo/ci/rcc.auto.tfvars</pre>
<p>Next, you can set the the <code>--rcc-tfvars</code> flag for rcc-run. Open the <code>ci/cloudbuild.yaml</code> file and edit the RCC-Run build step so that it looks like this.</p>
<pre>- id: RCC-Run
  name: &#39;gcr.io/${PROJECT_ID}/rcc-run:latest&#39;
  args:
  - &#39;--build-id=${BUILD_ID}&#39;
  - &#39;--git-sha=${COMMIT_SHA}&#39;
  - &#39;--project=${PROJECT_ID}&#39;
  - &#39;--artifact-type=singularity&#39;
  - &#39;--singularity-image=smoother.sif&#39;
  - &#39;--rcc-tfvars=ci/rcc.auto.tfvars&#39;
  - &#39;--ci-file=ci/rcc-run.yaml&#39;
  - &#39;--save-results&#39;</pre>
<p>Here, we&#39;ve added <code>'--rcc-tfvars=ci/rcc.auto.tfvars'</code> so that RCC-Run will use the local <code>ci/rcc.auto.tfvars</code> file to define the cluster used for benchmarking.</p>
<h2 is-upgraded>Add a new partition to the benchmarking cluster</h2>
<p>Remember that the Slurm partitions are used to set up groups of compute nodes that all have the same property. Currently, the rcc.auto.tfvars file defines only one partition that has c2-standard-8 instances (8 Intel Cascadelake vCPU). In this example, we will add a partition that has AMD Epyc Milan CPUs.</p>
<p>Open the <code>ci/rcc.auto.tfvars</code> file in a text editor. Copy the c2-standard-8 partition and paste it beneath this partition definition. Set the name and machine_type fields to c2d-standard-8; the c2d-standard-8 machine type will provide 8 AMD Epyc Milan vCPU per node.</p>
<aside class="special"><p><strong>Note</strong>: You can learn more about the available machine types on Google Cloud in the <a href="https://www.google.com/search?q=google+cloud+machine+types&oq=google+cloud+machine+&aqs=chrome.0.69i59j69i57j69i60l6.2148j0j7&sourceid=chrome&ie=UTF-8" target="_blank">Compute Engine Documentation</a>.</p>
</aside>
<p>Your partitions in the  rcc.auto.tfvars should look like this.</p>
<pre>partitions = [
  { name                 = &#34;c2-standard-8&#34;
    machine_type         = &#34;c2-standard-8&#34;
    image                = &#34;&lt;image&gt;&#34;
    image_hyperthreads   = true
    static_node_count    = 0
    max_node_count       = 5 
    zone                 = &#34;&lt;zone&gt;&#34;
    compute_disk_type    = &#34;pd-standard&#34;
    compute_disk_size_gb = 100
    compute_labels       = {}
    cpu_platform         = null
    gpu_count            = 0
    gpu_type             = null
    gvnic                = false
    network_storage      = []
    preemptible_bursting = false
    vpc_subnet           = null
    exclusive            = false
    enable_placement     = false
    regional_capacity    = false
    regional_policy      = null
    instance_template    = null
  },
  { name                 = &#34;c2d-standard-8&#34;
    machine_type         = &#34;c2d-standard-8&#34;
    image                = &#34;&lt;image&gt;&#34;
    image_hyperthreads   = true
    static_node_count    = 0
    max_node_count       = 5
    zone                 = &#34;&lt;zone&gt;&#34;
    compute_disk_type    = &#34;pd-standard&#34;
    compute_disk_size_gb = 100
    compute_labels       = {}
    cpu_platform         = null
    gpu_count            = 0
    gpu_type             = null
    gvnic                = false
    network_storage      = []
    preemptible_bursting = false
    vpc_subnet           = null
    exclusive            = false
    enable_placement     = false
    regional_capacity    = false
    regional_policy      = null
    instance_template    = null
  },
]</pre>
<h2 is-upgraded>Add a zone option for deployment</h2>
<p>Now, because the c2d instances are available in <a href="https://cloud.google.com/compute/docs/regions-zones#available" target="_blank">select Google Cloud zones</a>, we need to add a build option to set the zone to deploy the cluster to; by default, <code>rcc-run</code> uses <code>us-west1-b</code>, where c2d instances are not available.</p>
<p>First, we&#39;re going to add a <a href="https://cloud.google.com/build/docs/configuring-builds/substitute-variable-values" target="_blank">substitution variable to the Cloud Build </a>build pipeline. Open <code>ci/cloudbuild.yaml</code> in a text editor. Add the following substitutions definition to the <code>ci/cloudbuild.yaml</code> file</p>
<pre>substitutions:
  _ZONE: &#39;us-west1-b&#39;</pre>
<p>Here, we are adding a substitution variable called <code>_ZONE</code> that defaults to us-west1-b. Next, we&#39;ll use the <code>--zone</code> flag for RCC-Run so that we can use the substitution variable to set the deployment zone for the cluster. Open the <code>ci/cloudbuild.yaml</code> file and edit the RCC-Run build step so that it looks like this.</p>
<pre>- id: RCC-Run
  name: &#39;gcr.io/${PROJECT_ID}/rcc-run:latest&#39;
  args:
  - &#39;--build-id=${BUILD_ID}&#39;
  - &#39;--git-sha=${COMMIT_SHA}&#39;
  - &#39;--project=${PROJECT_ID}&#39;
  - &#39;--zone=${_ZONE}&#39;
  - &#39;--artifact-type=singularity&#39;
  - &#39;--singularity-image=smoother.sif&#39;
  - &#39;--rcc-tfvars=ci/rcc.auto.tfvars&#39;
  - &#39;--ci-file=ci/rcc-run.yaml&#39;
  - &#39;--save-results&#39;</pre>
<p>To test that everything works, you can manually trigger the build while setting the zone to <code>us-central1-a</code>, which hosts both c2 and c2d instances.</p>
<pre>gcloud builds submit . --config=ci/cloudbuild.yaml --substitutions=_ZONE=us-central1-a --async</pre>


      </google-codelab-step>
    
      <google-codelab-step label="Congratulations" duration="0">
        <p>In this codelab, you learned how to use Google Cloud Build to define a build and testing pipeline for a compiled application. Additionally, you learned how to use <a href="https://github.com/fluidnumerics/rcc-run" target="_blank">RCC-Run</a> to automate logging of benchmark results while providing access to a wider variety of compute resources for application benchmarking. </p>
<p>To automate benchmarking upon pushing commits, pushing tags, or opening pull requests, we encourage you to learn how to <a href="https://cloud.google.com/build/docs/automating-builds/create-manage-triggers" target="_blank">create and manage build triggers</a>. Further, there are a number of tools available to dashboard your benchmarking data that easily integrate with <a href="https://cloud.google.com/bigquery" target="_blank">BigQuery</a>; we highly recommend using <a href="https://datastudio.google.com/" target="_blank">Data Studio</a>, a free application from Google.</p>
<h2 is-upgraded><strong>Provide Feedback</strong></h2>
<p>If you have any questions, comments, or feedback that can help improve this codelab, you can reach out to <a href="mailto:support@fluidnumerics.com" target="_blank">support@fluidnumerics.com</a> </p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
